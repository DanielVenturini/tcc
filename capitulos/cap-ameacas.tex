\chapter{Ameaças à Validade}
\label{cap:threats}

Neste capítulo descrevemos os detalhes sobre as circunstâncias que podem fazer com que os resultados variar.

\subsubsection{Ameaças à validade interna}
Quando uma \textit{breaking change} era detectada, foi verificado o tipo da alteração que o provedor introduziu e causou a \textit{breaking change} e elas foram categorizadas da maneira mais genérica possível. Entretanto, alguns casos se encaixariam muito bem e mais de uma categoria. Por exemplo, um provedor que alterou o tipo de objeto para alterar toda uma funcionalidade. Esse caso de \textit{breaking change} poderia ser classificado como \textit{Alteração de comportamento} e \textit{Alteração do tipo de objeto}. Casos como esse foram categorizados na categoria mais expressiva da alteração. Nesse caso, o objeto foi alterado por causa de uma alteração no comportamento do pacote. Então, a categoria mais apropriada foi selecionada como \textit{Alteração de comportamento}.

Os casos de erros do tipo \textit{breaking change induzida} são aqueles que os pacotes usam dados de sites e \textit{APIs}. Esses dados alteram-se ao longo do tempo (Ver Subseção \ref{subsec:break_without}) e os pacotes não têm controle sobre esses dados. As \textit{releases} impactadas por \textit{breaking changes} induzidas representam 9.3\% das \textit{releases} do cliente. Nesses casos, não foi verificado se havia ou não \textit{breaking change}, uma vez que não foi possível executar os casos de testes. Então, quase 10\% das \textit{releases} dos clientes poderiam ser impactadas por \textit{breaking change} mas não foram analisadas.

\subsubsection{Ameaças à validade externa}
Os pacotes clientes foram selecionados de forma aleatória com uma variedade de características em termos da quantidade de \textit{releases}, provedores e tamanhos. Por isso, a amostra é diversa e pode ser facilmente generalizada. Além disso, o método utilizado neste trabalho pode ser replicado para outros ecossistemas porque outros gerenciadores de pacotes funcionam da mesma maneira que o \textsf{npm}. Ainda, vários desses ecossistemas utilizam o Versionamento Semântico para gerenciar as dependências e a análise nos repositórios hospedados no \textsf{GitHub} não é exclusiva para o ecossistema do \textsf{npm}.

Porém, uma vez que a base de dados é exclusiva do \textsf{npm}, os resultados estão muito relacionados com esse ecossistema e podem não ser generalizados com fidelidade para os outros ecossistemas. O ecossistema do \textsf{npm} possui muitas diferenças substanciais dos outros ecossistemas \cite{how_to_break_an_api}.

\subsubsection{Ameaças à validade de construção}
O método para detectar \textit{breaking changes} realizou uma análise tão completa quanto possível no cliente e no provedor. Foram analisados os casos em que os testes do cliente falhou, indicando um real caso de \textit{breaking change}. Foi analisado o código do cliente e do provedor, os \textit{commits}, \textit{changelogs}, \textit{issues}, \textit{pull-requests} e \textit{logs} de serviços integrados.

Porém, a análise só foi realizada quando um teste falhou. Se um cliente usava uma \textit{release} do provedor que continha uma \textit{breaking change}, mas o cliente não realizava uma chamada para a função que introduzia a \textit{breaking change}, então a \textit{breaking change} não se manifestou no cliente e não gerou erro. Não havia como identificar \textit{breaking change} nesses casos, pois só houve a análise quando houve um erro no teste do cliente. Assim, um fator importante para detectar \textit{breaking changes} é a qualidade do \textit{script} de teste do cliente, mas não foi analisada em nosso estudo.

Muitas das \textit{breaking changes} relacionadas às \textit{APIs} não foram detectadas. Basicamente, apenas foram detectadas casos no qual o provedor alterou o nome de uma \textit{API}. Outros casos não foram identificados porque o \textsf{Javascript} permite realizar chamadas para \textit{APIs} com qualquer número de parâmetros. Por exemplo, se um provedor removeu ou adicionou mais parâmetros à sua \textit{API}, o cliente ainda era capaz de realizar uma chamada para essa \textit{API} com os mesmos parâmetros que eram passados nas chamadas anteriores. Isso ocorre porque o \textsf{Javascript} insere todos os parâmetros dentro de uma variável chamada \texttt{arguments}\footnote{https://eloquentjavascript.net/03 functions.html\#p kzCivbonMM} e não se preocupa com a quantidade de parâmetros.

Por último, para cada \textit{release}, foram restaurados os arquivos da \textit{release} utilizando a \textit{tag} da respectiva \textit{release} que o desenvolvedor criou. Foram listados todas as \textit{tags} do repositório e foi realizado um \textit{checkout} com a \textit{tag} específica. Entretanto, para as \textit{releases} que o desenvolvedor não criou uma \textit{tag}, o \textit{checkout} foi realizado utilizando o \textit{timestamp} da \textit{release} no \textit{package.json}. Devido a necessidade de realizar o \textit{checkout} usando o \textit{timestamp}, foi verificado a confiabilidade dos \textit{timestamps}. Em repositórios que haviam \textit{tags}, 94\% dos casos a \textit{tag} e o \textit{timestamp} correspondiam o mesmo \textit{commit}.