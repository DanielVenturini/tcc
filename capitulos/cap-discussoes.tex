\chapter{Discussões}
\label{cap:discussoes}

O ponto principal deste trabalho é que realmente os pacotes provedores introduzem \textit{breaking changes} em \textit{releases minor} e \textit{patch}. Essas alterações, que se tornaram \textit{breaking changes}, deveriam ser introduzidas apenas em \textit{releases minor} para manter todas as \textit{releases minor}/\textit{patch} retro compatíveis, seguindo o Versionamento Semântico. Enquanto que a Subseção \ref{sub:disc:1} discute o gerenciamento de dependências na perspectiva do cliente, a Subseção \ref{sub:disc:2} apresenta algumas práticas técnicas que devem ser seguidas pelos pacotes \textit{clientes} e \textit{provedores} para evitar/mitigar o impacto das \textit{breaking changes}. Finalmente, a Subseção \ref{sub:disc:3} discute alguns aspectos gerais sobre \textit{breaking changes} no ecossistema do \textsf{npm}.

\subsection{Gerenciamento de dependências}
\label{sub:disc:1}

O gerenciamento de dependências é uma tarefa difícil para os pacotes clientes. Os clientes devem estar consciente sobre as versões de seus provedores e suas atualizações. Não é uma boa prática definir o \textit{range} dos provedores como \textit{X-range} ou um \textit{range} específico -- quando não há \textit{range}; especificado com a opção \texttt{--save-exact}. Foi verificado que esses são os tipos de \textit{range} menos comum, e o \textit{range all} provavelmente irá introduzir uma \textit{breaking change} no futuro. Ainda, o \textit{range} específico é tão prejudicial quanto o \textit{X-range}, uma vez que ele impede os clientes de serem atualizados com as novas \textit{releases} dos provedores. Portanto, foi verificado que algumas vezes os clientes estão utilizando versões desatualizadas dos provedores.

Os clientes podem utilizar atualizadores automáticos de dependências no \textsf{GitHub} para receberem \textit{pull-requests} quando há alguma nova versão dos provedores. Há o \textsf{Snyk} e o \textsf{Dependabot}. Esses automatizadores verificam continuamente por novas versões dos provedores que contenham correções de erros/vulnerabilidades e novas funcionalidades, de acordo com o \textit{range} especificado pelos clientes. Esses automatizadores exibem o \textit{changelog} de cada nova versão e criam \textit{pull-requests} nos repositórios dos clientes atualizando seus \textit{package.json}. O trabalho de \citeonline{automated_pull} mostra que os clientes que utilizam automatizadores como esses atualizam suas dependências 1.6 vezes mais rápidos do que se fossem atualizados manualmente.

Finalmente, os pacotes clientes devem usar métodos alternativos para se recuperarem das \textit{breaking changes} ao invés de simplesmente removerem/trocarem o provedor. Foi observado uma pequena porcentagem de clientes que removeram/trocaram o provedor após uma \textit{breaking change}. Essa baixa porcentagem é devido ao fato que os clientes usam várias funcionalidades/recursos dos pacotes provedores e ter que remover/trocar o provedor pode ser uma tarefa muito custosa \cite{automating_detecting_third-part_java_migration}. Consequentemente, os clientes podem realizar um \textit{downgrade} temporário para uma versão específica do provedor e verificar se isso impede a manifestação da \textit{breaking change}. Então, o cliente deve continuar a verificar continuamente por novas \textit{releases} do seu provedor. Também, quando os clientes forem atualizar a versão de um provedor, os clientes devem verificar os \textit{changelogs} dos provedores por alterações significativas para evitar receber uma alteração inesperada. De fato, como verificado nesse trabalho, a maioria das \textit{breaking changes} já estavam previamente documentadas em \textit{issues}, \textit{pull-requests} e \textit{changelogs}. Finalmente, os pacotes clientes devem sempre usar e incluir o arquivo \textit{package-lock.json} para evitar atualização implícita inesperada nos provedores. Como no terceiro exemplo motivacional (Capítulo \ref{cap:exemplos}), quando havia o \textit{package-lock.json}, o cliente não era impactado pela \textit{breaking change}, mas quando o \textit{package-lock.json} era removido, isso permitia que o \textsf{npm} atualizasse a versão dos provedores, introduzindo a \textit{breaking changes}.

\subsection{Melhores práticas}
\label{sub:disc:2}

Uma ferramenta muito útil que pode ser utilizada por desenvolvedores são os \textit{linters}. Um \textit{linter} realiza uma análise estática no código do desenvolvedor. Para lingagens dinâmicas como o \textsf{Javascript}, os \textit{linters} podem ser muito útil para evitar alguns tipos de erros \cite{js-linters}. Para \textsf{Javascript}, os \textit{linters} mais utilizados são \textsf{jslint}, \textsf{jshint} e \textsf{standard}. Vários casos de \textit{breaking changes} que foram detectados e categorizadas nesse trabalho (Seção \ref{sec:qp2:results}) poderiam ser evitados se os provedores usassem \textit{linters}. As \textit{breaking changes} classificadas como \textit{Código incorreto} e \textit{Renomeação de função} são facilmente capturadas por essas ferramentas de \textit{linting}. \citeonline{js-linters} e \citeonline{js-linters2} mostraram que um dos principais motivos que os desenvolvedores usam \textit{linters} são para prevenir erros.

Entretanto, devido à natureza dinâmica do \textsf{Javascript}, \textit{linters} não são capazes de verificar propriedades herdadas de objetos, então os erros classificados como \textit{Alteração de funcionalidade}, \textit{Alteração do tipo de objeto} e \textit{Objeto indefinido} -- ainda, \textit{Renomeação de função} em funções das propriedades de objetos -- não são capturadas pelos \textit{linters}. Portanto, os desenvolvedores devem criar casos de testes para descobrirem esses erros em tempo de execução. Há vários \textit{frameworks} disponíveis, tal como o \textsf{mocha}, \textsf{chai}, \textsf{ava} que realizam essas tarefas. Também, esses testes devem ser executados em sistemas integrados cada vez que os desenvolvedores realizarem um \textit{commit} e enviarem ao repositório. Para isso, há várias ferramentas disponíveis, tal como o \textsf{Travis}, \textsf{Jenkins}, \textsf{Drone CI} e \textsf{Codefresh}. Ao utilizar \textit{linters} e sistemas integrados , os desenvolvedores poderão descobrir a maioria dos casos de erros.

Também, os provedores devem estar conscientes sobre a quantidade de \textit{commits} introduzida em cada \textit{release}. Foi observado que mais da metade das \textit{releases} dos provedores com \textit{breaking changes} têm mais \textit{commits} do que a mediana das \textit{release} sem \textit{breaking change} no mesmo nível \textit{major}. Essas \textit{releases} com \textit{breaking changes} introduzem muitas alterações e isso pode se tornar difícil para os provedores gerenciarem todas essas alterações em apenas uma \textit{release}: podem ser introduzidas mais alterações do que o planejado. Ou seja, algumas \textit{releases} deveriam ser segmentada em duas ou mais \textit{releases}. Portanto, os provedores devem manter as \textit{releases} o mais concisa possível, introduzindo apenas \textit{commits} consistentes, restringindo o número de \textit{commits}.

Finalmente, os provedores -- e qualquer outro pacote do ecossistema do \textsf{npm} -- devem manter um \textit{changelog}. Com um \textit{changelog} consistente muitos erros poderiam ser facilmente rastreados e consertados. Foi observado que as correções em \textit{breaking changes} que haviam sido documentadas em \textit{changelogs}, \textit{issues} ou \textit{pull-requests} ocorrem 3.3 vezes mais rápido do que as \textit{breaking changes} não documentadas. Então, os provedores podem criar templates para as \textit{issues} e \textit{pull-requests} para permitir outros desenvolvedores a especificar detalhes mais consistentes e precisos nessas \textit{issues} e \textit{pull-requests} para facilitar o rastreamento das \textit{breaking changes}.

\subsection{Discussões gerais}
\label{sub:disc:3}
As \textit{breaking changes} estão crescendo ao longo do tempo. Foi detectado um crescimento de 46.6\% para cada ano. Ou seja, para cada \textit{breaking change} em um dado ano haverão quase duas no ano seguinte. Foi detectado que a maioria das \textit{breaking changes} são introduzidas por provedores indiretos, ou seja, são provedores que estão a partir do segundo nível na árvore de dependências. Esses provedores não são instalados diretamente pelos clientes, mas eles são instalados quando um provedor direto é instalado pelo \textsf{npm}. O trabalho de \citeonline{npm-seven} mostra que metade dos clientes no ecossistema do \textsf{npm} têm pelo menos 22 dependências transitivas (provedores indiretos), e um quarto possui pelo menos 95 dependências transitivas, em 2016. Esse grande e crescente número potencializa o surgimento de \textit{breaking changes} pelos provedores diretos e indiretos.

Por fim, o Versionamento Semântico é apenas uma politica do qual os provedores podem decidir usar ou não \cite{decan}. Se os provedores não seguem as regras do Versionamento Semântico, muitas erros podem ser introduzidos. Foi observado que todas as \textit{breaking changes} introduzidas em \textit{pre-releases} foram propagadas para as \textit{releases} estáveis. Portanto, os provedores podem estar desorientados acerca do Versionamento Semântico, mesmo sendo um conjunto simples de regras. Por fim, as regras do Versionamento Semântico descreve as \textit{breaking changes} apenas como \textit{Alterações incompatíveis de APIs},\footnote{https://semver.org/\#summary} mas foi verificado vários outros tipos de \textit{breaking changes} que os provedores podem introduzir; alterações de API é apenas um subconjunto de \textit{breaking changes}.