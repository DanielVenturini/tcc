\chapter{Discussões}
\label{cap:discussoes}

O principal resultado deste trabalho é que realmente os pacotes provedores introduzem \textit{breaking changes} em \textit{releases minor} e \textit{patch}. Essas alterações, que se tornaram \textit{breaking changes}, deveriam ser introduzidas apenas em \textit{releases major} para manter todas as \textit{releases minor}/\textit{patch} retro compatíveis, seguindo o Versionamento Semântico. A Subseção \ref{sub:disc:1} discute o gerenciamento de dependências na perspectiva do cliente. A Subseção \ref{sub:disc:2} apresenta algumas práticas que podem ser seguidas pelos pacotes \textit{clientes} e \textit{provedores} para evitar/mitigar o impacto das \textit{breaking changes}. Finalmente, a Subseção \ref{sub:disc:3} discute alguns aspectos gerais sobre \textit{breaking changes} no ecossistema do \textsf{npm}.

\section{Gerenciamento de dependências}
\label{sub:disc:1}

O gerenciamento de dependências é uma tarefa difícil para os pacotes clientes. Os clientes devem estar consciente sobre as versões de seus provedores e suas atualizações. Não é uma boa prática definir o \textit{range} dos provedores como \textit{X-range} ou como um \textit{range} específico -- quando não há \textit{range}, especificado com a opção \texttt{--save-exact} no processo de instalação. Foi verificado que esses são os tipos de \textit{range} menos comum (Descoberta \#6). Ainda, o \textit{range} específico é tão prejudicial quanto o \textit{X-range}, uma vez que ele impede os clientes de serem atualizados com as novas \textit{releases} dos provedores, enquanto que o \textit{X-range} provavelmente irá introduzir uma \textit{breaking change} no futuro. Portanto, foi verificado que algumas vezes os clientes estão utilizando versões desatualizadas dos provedores (Descoberta \#12).

Para facilitar o gerenciamento de dependências, os clientes podem utilizar atualizadores automáticos de dependências no \textsf{GitHub} para receberem \textit{pull-requests} quando há alguma nova versão dos provedores. Exemplos são o \textsf{Snyk} e o \textsf{Dependabot}. Esses automatizadores verificam continuamente por novas versões dos provedores que contenham correções de erros/vulnerabilidades e novas funcionalidades, de acordo com o \textit{range} especificado pelos clientes. Esses automatizadores exibem o \textit{changelog} de cada nova versão e criam \textit{pull-requests} nos repositórios dos clientes atualizando seus \textit{package.json}. O trabalho de \citeonline{automated_pull} mostra que os clientes que utilizam automatizadores como esses atualizam suas dependências 1.6 vezes mais rápidos do que se fossem atualizados manualmente.

Finalmente, os pacotes clientes devem usar métodos alternativos para se recuperarem das \textit{breaking changes} ao invés de simplesmente removerem/trocarem o provedor. Foi observada uma pequena porcentagem de clientes que removeram ou trocaram o provedor após uma \textit{breaking change} (Descoberta \#12). Essa baixa porcentagem é devido ao fato de que os clientes usam várias funcionalidades/recursos dos pacotes provedores e ter que remover/trocar o provedor pode ser uma tarefa muito custosa \cite{automating_detecting_third-part_java_migration}. Consequentemente, os clientes podem realizar um \textit{downgrade} temporário para uma versão específica do provedor e verificar se isso impede a manifestação da \textit{breaking change}. Então, o cliente deve continuar a verificar continuamente por novas \textit{releases} do seu provedor. Ainda, quando os clientes forem atualizar a versão de um provedor, os clientes devem verificar os \textit{changelogs} dos provedores por alterações significativas para evitar alterações inesperadas. De fato, como verificado nesse trabalho, a maioria das \textit{breaking changes} possuem documentação em  \textit{changelogs}, \textit{issues}, \textit{pull-requests} (Descoberta \#8). Finalmente, os pacotes clientes devem sempre usar e incluir o arquivo \textit{package-lock.json} para evitar atualização implícita inesperada nos provedores. Como no terceiro exemplo motivacional (Capítulo \ref{cap:exemplos}), quando havia o \textit{package-lock.json}, o cliente não era impactado pela \textit{breaking change}, mas quando o \textit{package-lock.json} era removido, isso permitia que o \textsf{npm} atualizasse a versão dos provedores, introduzindo a \textit{breaking change}.

\section{Melhores práticas}
\label{sub:disc:2}

Uma ferramenta muito útil que pode ser utilizada por desenvolvedores são os \textit{linters}. Um \textit{linter} realiza uma análise estática no código do desenvolvedor. Para lingagens dinâmicas como o \textsf{Javascript}, os \textit{linters} podem ser muito úteis para evitar alguns tipos de erros \cite{js-linters}. Para \textsf{Javascript}, os \textit{linters} mais utilizados são \textsf{jslint}, \textsf{jshint} e \textsf{standard}. Vários casos de \textit{breaking changes} detectados e categorizadas nesse trabalho (Seção \ref{sec:qp2:results}) poderiam ser evitados se os provedores usassem \textit{linters}. As \textit{breaking changes} classificadas como \textit{Código incorreto} e \textit{Renomeação de função} são facilmente capturadas por essas ferramentas de \textit{linting}. \citeonline{js-linters} e \citeonline{js-linters2} mostraram que um dos principais motivos que os desenvolvedores usam \textit{linters} são para prevenir erros.

Entretanto, devido à natureza dinâmica do \textsf{Javascript}, \textit{linters} não são capazes de verificar propriedades herdadas de objetos, então os erros classificados como \textit{Alteração de funcionalidade}, \textit{Alteração do tipo de objeto} e \textit{Objeto indefinido} -- ainda, \textit{Renomeação de função} em funções das propriedades de objetos -- não são capturadas pelos \textit{linters}. Portanto, os desenvolvedores devem criar casos de testes para descobrirem esses erros em tempo de execução. Há vários \textit{frameworks} disponíveis, tal como o \textsf{mocha}, \textsf{chai}, \textsf{ava} que realizam essas tarefas. Esses testes devem ser executados em integração contínua cada vez que os desenvolvedores realizarem um \textit{commit} e enviarem ao repositório. Para isso, há várias ferramentas disponíveis, tal como o \textsf{Travis}, \textsf{Jenkins}, \textsf{Drone CI} e \textsf{Codefresh}. Ao utilizar \textit{linters} e integração contínua, os desenvolvedores poderão descobrir a maioria dos casos de erros.

Os provedores devem estar conscientes sobre a quantidade de \textit{commits} introduzida em cada \textit{release}. Foi observado que mais da metade das \textit{releases} dos provedores com \textit{breaking changes} têm mais \textit{commits} do que a mediana das \textit{release} sem \textit{breaking change} no mesmo nível \textit{major} (Descoberta \#4). Essas \textit{releases} com \textit{breaking changes} introduzem muitas alterações e isso pode ser difícil gerenciar todas essas alterações em apenas uma \textit{release}: podem ser introduzidas mais alterações do que o planejado. Ou seja, algumas \textit{releases} deveriam ser segmentada em duas ou mais \textit{releases}. Portanto, os provedores devem manter as \textit{releases} o mais concisas possível, introduzindo apenas \textit{commits} consistentes, restringindo o número de \textit{commits}.

Finalmente, os provedores -- e qualquer outro pacote do ecossistema do \textsf{npm} -- devem manter um \textit{changelog}. Com um \textit{changelog} consistente muitos erros poderiam ser facilmente rastreados e consertados. Foi observado que as correções em \textit{breaking changes} que haviam sido documentadas em \textit{changelogs}, \textit{issues} ou \textit{pull-requests} ocorrem 3.3 vezes mais rápido do que as \textit{breaking changes} não documentadas (Descoberta \#14). Assim, os provedores podem criar \textit{templates} para as \textit{issues} e \textit{pull-requests} para permitir outros desenvolvedores a especificar detalhes mais consistentes e precisos nessas \textit{issues} e \textit{pull-requests} para facilitar o rastreamento das \textit{breaking changes}.

\section{Crescimento das \textit{breaking changes} e o Versionamento Semântico}
\label{sub:disc:3}
Os casos \textit{breaking changes} estão crescendo ao longo do tempo. Foi detectado um crescimento de 63.4\% para cada ano (Descoberta \#3). Ou seja, para cada \textit{breaking change} em um dado ano haverão quase duas no ano seguinte. Detectamos que a maioria das \textit{breaking changes} são introduzidas por provedores indiretos, ou seja, são provedores que estão a partir do segundo nível na árvore de dependências. Esses provedores não são instalados diretamente pelos clientes, mas eles são instalados quando um provedor direto é instalado pelo \textsf{npm}. O trabalho de \citeonline{npm-seven} mostra que metade dos clientes no ecossistema do \textsf{npm} têm pelo menos 22 dependências transitivas (provedores indiretos), e um quarto possui pelo menos 95 dependências transitivas, em 2016. Esse grande e crescente número potencializa o surgimento de \textit{breaking changes} pelos provedores diretos e indiretos.

Por fim, o Versionamento Semântico é apenas uma politica da qual os provedores podem decidir usar ou não \cite{decan}. Se os provedores não seguem as regras do Versionamento Semântico, muitas erros podem ser introduzidos. Foi observado que todas as \textit{breaking changes} introduzidas em \textit{pre-releases} foram propagadas para as \textit{releases} estáveis (Descoberta \#6). Portanto, os provedores podem estar desorientados acerca do Versionamento Semântico, mesmo sendo um conjunto simples de regras. Ainda, as regras do Versionamento Semântico descrevem as \textit{breaking changes} apenas como \textit{Alterações incompatíveis de APIs},\footnote{https://semver.org/\#summary} mas foi verificado vários outros tipos de \textit{breaking changes} que os provedores podem introduzir (Descoberta \#5); alterações de \textit{API} é apenas um subconjunto de \textit{breaking changes}.