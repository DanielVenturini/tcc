\section{RQ1. Com que frequência \textit{breaking changes} surgem nos pacote clientes?}
\label{sec:rq1}

\subsection{Motivation}
\label{mot:rq1}

Atualmente, o \Gls{NPM} contém mais de 11 bilhões de downloads semanais e ultrapassa os 45 bilhões por mês. Os pacotes hospedados no \Gls{NPM} são usados por milhões de pessoas e projetos por todo o mundo. Eles são gratis, e fáceis de usar. Entretanto, uma simples \textit{release} que contenha um erro pode afetar uma quantidade imensa de pacotes. Isso se deve ao fato dos pacotes dependerem uns dos outros, direta ou indiretamente e, quando uma \textit{release} introduz \textit{breaking changes}, muitos pacotes podem ser afetados.

Para evitar estes erros, o \Gls{NPM} utiliza \textit{strings} de versionamento, baseadas no \Gls{SEMVER} para especificar as versões dos provedores. Isso permite que um provedor publique uma \textit{release} que contenha \textit{breaking changes}, mas que não afete os clientes das versões prévias. Entretanto, pesquisas mostram que a distinção entre \textit{breaking} e \textit{non-breaking changes} não é totalmente clara e pode ser difícil para o desenvolvedor decidir como incrementar a \textit{string} de versionamento a cada \textit{release} \cite{noregrets2018}. Assim sendo, entender com que frequência os pacotes provedores publicam \textit{releases} com \textit{breaking changes} pode ajudar os clientes a fazerem uma decisão melhor sobre como e quando atualizar a versão do provedor.

Para responder essa questão de pesquisa, serão analisados três pontos: 1) quantas vezes cada provedor publica uma \textit{release} que contém \textit{breaking changes} - e qual é a porcentagem de \textit{releases}; 2) em qual nível da \textit{string} de versionamento as \textit{breaking changes} são tipicamente introduzidas, de acordo com o \Gls{SEMVER} - \textit{major, minor} ou \textit{patch}; 3) qual o percentual de clientes que atualizam para uma versão com \textit{breaking changes}.

Para analisar todos esses pontos, os pacotes sorteados foram clonados do \textit{GitHub}, atualizado o \textit{index} e os arquivos na \textit{Working Tree} através do comando \textit{git checkout} com o \textit{timestamp} da \textit{release}, excluido o arquivo \textit{package-lock.json}, atualizado a versão de cada um dos provedores no \textit{package.json} e executado os comandos \textit{npm install} e \textit{npm test}. Todo esse processo foi executado automaticamente pela ferramenta \textit{BCDetect} \footnote{https://github.com/danielventurini/bcdetect}. Então, o resultado da execução -- sucesso ou erro -- foi salvo juntamente com as informações sobre a versão do \textit{Node.JS} que foi executado e que deveria ter sido executada, de acordo com o \textit{timestamp}. % essa parte das versões eu vou explicar melhor em um capítulo falando sobre a ferramenta.

\subsection{Approach}
\label{apr:rq1}
Um \textit{stack trace} contém as informações sobre as subrotinas de um programa. É comumente utilizado para certos tipos de \textit{debugs}, nos quais eles auxiliam a visualizar e rastrear um determinado evento/erro. Quando os comandos \textit{npm install} e \textit{npm test} resultam em erro, o \Gls{NPM} mostra o erro e todas as chamadas de função, incluindo as invocações para os provedores. A Figura \ref{fig:trace} mostra um exemplo genérico de um \textit{stack trace} mostrado pelo \Gls{NPM} após a ocorrência de um erro.

\begin{figure}
    \centering
    \includegraphics[scale=0.7]{figuras/stack_trace.jpeg}
    \caption{Generic stack-trace}
    \label{fig:trace}
\end{figure}{}

O \textit{stack trace} é a base para analisar um erro. A primeira etapa da análise de um erro é diferenciar entre um erro que foi causado pelo próprio pacote cliente, no qual não houve influência de nenhum provedor, portanto não caracteriza uma \textit{breaking change}, e um erro que foi causado por algum dos provedores, no qual se propagou para o pacote cliente e interrompeu-lhe a execução. Há duas maneiras que foi utilizada para realizar esta análise.

A primeira maneira foi verificar diretamente no \textit{stack trace} do erro e procurar as chamadas de função para os provedores. Quando não há chamada para os provedores no \textit{stack trace}, provavelmente o erro não se trata de uma \textit{breaking change}, porque nenhum provedor influenciou em nada na execução até acontecer o erro. Então, a falha pode estar apenas no código do cliente. Para confirmar isto, foi procurado no \textit{GitHub} do cliente os próximos \textit{commits} e verificado se o desenvolvedor realizou alguns \textit{commits} com a intenção de consertar algum erro - mensagens do tipo \textit{fix error}, \textit{fix bugs} etc. Se sim, o código do cliente foi alterado para verificar se as modificações presentes nos \textit{commits} realmente refletem a correção do erro. Então este caso foi confirmado como um \textit{non-breaking change} e foi descartado. Entretanto, alguns tipos de erros já indicam exatamente onde o erro aconteceu. São os \textit{SyntaxError} e \textit{ReferenceError}, no qual já se sabe onde e porque ocorreu. O Código \ref{cod:syntax:error} mostra um exemplo deste tipo de erro.

\begin{lstlisting}[style=Javascript, label=cod:syntax:error, caption={Código com um Reference Error}]
const a = 0 = 0;
\end{lstlisting}

Nesses casos, no qual o erro estava no pacote cliente, nem se fez necessário procurar por \textit{commits} no \textit{GitHub}. Apenas foi consertado diretamente no código do cliente e re-executado o comando que resultou em erro: \textit{install} ou \textit{test}. Isto para garantir que não houvesse um segundo erro que pudesse ser uma \textit{breaking change}.

A segunda maneira é quando o erro indicava a presença de \textit{breaking changes}. Isto se evidenciava quando havia chamadas para os provedores no \textit{stack trace}. Entretanto, as chamadas para \textit{frameworks} de teste, como o \textit{Mocha, Instanbul, Jasmine} entre outros, ou automatizadores de tarefas, o \textit{Grunt} por exemplo, não evidenciam diretamente a presença de \textit{breaking changes} uma vez que eles apenas iniciam a execução do pacote e deveriam estar ali. Porém, não foram totalmente descartados de apresentar \textit{breaking changes}. Assim, quando havia algum provedor no \textit{stack trace}, provavelmente se tratava de um caso de \textit{breaking change}.

O melhor local para se confirmar esta evidência é o \textit{GitHub}. Neste, os repositórios dos pacotes contêm todo o histórico de desenvolvimento. E muitas maneiras foram utilizadas para recuperar as informações necessárias. A primeira e mais fácil foi procurar nos arquivos registros de alterações, os comumente nomeados de \textit{CHANGELOG.md} ou \textit{HISTORY.md}. A proposta destes arquivos é manter uma lista ordenada cronologicamente das alterações significativas ao longo do desenvolvimento do projeto. E uma das informações muito importantes que são descritas nesses registos são as \textit{breaking changes}. Por exemplo, a versão \textit{5.0.0} do projeto \textit{Mocha} \footnote{https://github.com/mochajs/mocha} contém uma \textit{breaking change} que foi documentada no \textit{CHANGELOG.md}\footnote{https://github.com/mochajs/mocha/blob/master/CHANGELOG.md\#500--2018-01-17}. A Figura \ref{fig:bc_documentation} ilustra como foi realizada esta documentação.

\begin{figure}
    \centering
    \includegraphics[scale=0.55]{figuras/bc_documentation.jpeg}
    \caption{Breaking Change documentation in README}
    \label{fig:bc_documentation}
\end{figure}{}

Assim, foi observado a versão do provedor que possivelmente causou o erro e foi verificado no seu \textit{CHANGELOG} -- caso existisse -- se contém alguma informação pertinente ao erro que foi apresentado pelo \gls{NPM} quando resultou em erro. Então foi salva as informações sobre este erro: a versão que iniciou, a versão que foi corrigido, uma breve descrição para facilitar a classificação da \textit{breaking change}, quem consertou o erro: cliente ou provedor; o tempo total até ser corrigido, quantas \textit{releases} o provedor levou para corrigir e em qual nível do \gls{SEMVER} o erro foi consertado.

Há ainda outros tipos de documentações parecidas com os \textit{changelogs}. Uma delas são as \textit{releases notes}. Elas são observações importantes sobre as alterações introduzidas por cada \textit{release}. Além disso, foi verificado nas \textit{issues} dos repositórios. Lá, muitas informações foram encontradas. E muito mais, pois há uma grande rede interligada de \textit{issues} e \textit{pull-requests} no qual uma \textit{issue} é marcada em outra \textit{issue}, que é marcada em um \textit{pull-request} e assim por diante. Deste modo, uma simples \textit{issue}/\textit{pull-request} contém muita informação.

Um ponto que foi muito importante para descobrir as versões que foram introduzidas as \textit{breaking changes} é a instalação de versões prévias e sucessivas dos provedores. Com isso, foi possível testar a partir de qual versão o erro foi introduzido e consertado e descobrir qual foi o verdadeiro provedor causador do erro. Também, alguns outros recursos foram utilizados para buscar as informações desta questão de pesquisa, tais como, o uso da ferramenta \textit{npm-diff}\footnote{https://github.com/danielventurini/npm-diff}, que provê os \textit{diff} do código entre duas \textit{releases} de um determinado projeto, no qual foi verificado o que realmente foi introduzido e o que foi removido com mais detalhes.

A Figura \ref{fig:step_analyze} exemplifica as técnicas para utilizadas para responder esta questão de pesquisa.

\begin{figure}
    \centering
    \includegraphics[scale=0.35]{figuras/step_analyze.jpeg}
    \caption{Passos para analisar um erro}
    \label{fig:step_analyze}
\end{figure}

Some integrated systems can help to discover breaking changes. These systems are \textit{Travis, Jenkins, Codeship, CircleCI} and so on, and store the results of the \Gls{NPM} install and \Gls{NPM} test in the moment of a commit. It can help in the following way: if in the commit of a release the status of \Gls{NPM} install or \Gls{NPM} test was a success, and now is an error, then it occurred by a provider because the code of client is the same in the working tree and only the provider code was updated. However, just some of the sorted packages contain an integrated system.

Another detail is the packages that connect with some type of service likes, \textit{MySql, CouchDB, Redis} and so on. From all 385 packages, x required one of these services. When the \textit{\Gls{NPM} install} or \textit{\Gls{NPM} test} raises an error because of the connection, in manual analyze the required services were ability and re-executed the package. So, if the error was persister because the connection, the package was classified was \textit{Undiscovered Error}.

So, from all release analyze was saved many informations:

\begin{enumerate}
    \item Documentation about the error: issue, changelog, pull-request and so on;
    \item Who fixed the error: client or provider;
    \item How long did the error take to get fixed;
    \item Fixed in major, minor or patch; and
    \item In how many releases the error existed.
\end{enumerate}{}

Nor all information may be recovered. For example, if an error wasn't fixed, then neither the client nor the provider repaired the error.

\subsection{Findings}
\label{fin:rq1}

%---------------------------------------------------%
\section{RQ2. Quais são os problemas no pacote provedor que causam breaking change?}
\label{sec:rq2}

\subsection{Motivation}
\label{mot:rq2}

Since the provider has unexpected behavior, there's a breaking change. It can cause a change in client behavior and, in the worst cause, can break all the execution if the error isn't previous catch by the client. However, the client doesn't expect an error.

The provider may contain multiple errors in his code. A simple semantic wrong line can break all execution because the \textit{Javascript} code isn't compiled. The types of errors in \textit{breaking changes} are many.  The error can be a change in the rules of behavior of the provider, in which this update in the behavior should be inserted in a \textit{major} release. Also, the type of returned object that isn't expected by the client can break it. And, of course, many and many other types of error.

However, the provider can have a provider that contains an error. In this cause, the first provider doesn't contain an error, but, for a wrong provider, one error is propagated to the client. This is a transitive breaking change and, in our research, is a normal cause of \textit{breaking change}.

To answer this research question, we analyze one by one and we categorized the type of \textit{breaking change}. Also, the types were quantified by category, by the number of releases and the number of clients that were affected by this category of breaking change.

\subsection{Approach}
\label{apr:rq2}

For each error in \textit{\Gls{NPM} install} or \textit{\Gls{NPM} test}, it was manually analyzed. The objective is to do a grouping of similar errors and categorize then. For example, Figure \ref{fig:error_category} shows two errors in which one a function was renamed and the client tries to access the previous name.

\begin{figure}[!h]
    \centering
    \includegraphics[scale=0.5]{figuras/error_category.jpeg}
    \caption{Two error caused by a renamed function}
    \label{fig:error_category}
\end{figure}

The first error in the Figure \ref{fig:error_category} is obvious: the client tries to access a variable like a function when it isn't a function. The second error talks about a property \textit{writable} that is access by an undefined object. There isn't any information about the function-related error, but, in manually analyze, it was observed that the provider change the name of a function. For this, in this code, the variable \textit{this.stream.writable} is undefined.

Once the provider causing the \textit{breaking change} has been discovered, there are several ways to find out the real reason that caused the error. These ways are described in Section \ref{apr:rq1}. Then, all \textit{breaking changes} are classified based on his type.

\subsection{Findings}
\label{fin:rq2}

%---------------------------------------------------%
\section{RQ3. Como os pacotes clientes se recuperam das breaking change?}
\label{sec:rq3}

\subsection{Motivation}
\label{mot:rq3}

Once a breaking change appears, the provider should fix it. It’s necessary because, in the \Gls{NPM} ecosystem, where hundreds of thousands of packages are connected, a single wrong release can break a lot of other packages. An example of this is the package called \textit{left-pad}, which was removed from \Gls{NPM} by your developer and break many thousands of projects on only 2.5 hours.

The responsibility to fix the release is from the provider, but, sometimes, the provider cannot fix the release/package for some reason. Then, the customer gets this responsibility because your wrong provider affects it and all of your customers are also affected. In the example of \textit{left-pad}, the provider never published a new release and, for all packages to continue working, the client's packages that have fixed this error publishing a new package with the same name and the same code.

However, the client may not know how to solve the problem. If the client is a simple user that only knows a little bit about the internal works from the provider, he can hardly solve in its own code an error that is being caused by the provider. This is very bad for the clients because he should fix the error, change to a previous version or choose another provider.

To answer the final research question, we analyze three points: 1) What happened so the provider couldn't fix the code; 2) How the client fixed the error or just notified the provider; 3) How many times the client fixed the error. All information about this research question is recovered by the \textit{release-notes, issues}, and \textit{pull-requests}.

\subsection{Approach}
\label{apr:rq3}

Since the customer recovers from the error, there are two ways to know how it recoverer. The first way is when the provider fixes his code and the client just updates the string of versioning in \textit{package.json}, if it needs. To the provider fixes the error, one issue may be done in his repository. The second way is when the client must do some work to fix the code. In this case, the client can fix the provider code and do a pull-request or change his code to work with the provider. And of course, may have cases that anyone does nothing. There is a breaking change and it’s never been fixed.

Where information about this RQ is retrieved is \textit{GitHub}. This information can be found at \textit{CHANGELOG, release-notes, issues,} and \textit{pull-requests}. If the \textit{changelog} contains information about fixed errors, in general, the related \textit{issues} are marked. From these \textit{issues}, a lot of more information can be recovered, like \textit{pull-requests} that are also marked in the \textit{issue}, other \textit{issues}, commentaries and more. All of this information can help us to discover which one -- client or provider -- fixed the \textit{breaking change} and how it was fixed.

\textit{Commits} are the alternative to \textit{issues} when the search is in the client repository. The \textit{commits} contain all changes in files and the all updates providers in \textit{package.json}. Commits message like \textit{update dependencies, fix dependencies, fix errors} an so on, suggests that something about any dependencies was fixed. This information is very important, because, since the provider was fixed and the client just updates it, the commit messages can tell the reason for this update - or downgrade.

\subsection{Findings}
\label{fin:rq3}